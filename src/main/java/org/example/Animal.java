package org.example;

/**
 * ============================================
 * БАЗОВЫЙ КЛАСС ANIMAL - УРОК ООП №1
 * ============================================
 * 
 * Это абстрактный класс. Почему? Потому что "животное" - это концепция,
 * а не конкретный зверь. Ты не можешь создать просто "животное" -
 * оно всегда КОТ, СОБАКА или ПТИЦА.
 * 
 * Аналогия: как "транспорт" - это идея, а не вещь.
 * Ты не можешь сесть в "транспорт", ты садишься в МАШИНУ или ВЕЛОСИПЕД.
 * 
 * АБСТРАКТНЫЙ КЛАСС = шаблон, который нельзя использовать напрямую.
 */
public abstract class Animal {
    
    // ============================================
    // ИНКАПСУЛЯЦИЯ - ПРИНЦИП №1
    // ============================================
    // private = закрытая переменная. Это как нижнее белье:
    // ты не хочешь, чтобы все видели твой hungerLevel!
    // 
    // Инкапсуляция = спрятать данные и дать контролируемый доступ.
    // Почему? Чтобы никто не мог сделать hungerLevel = -999999
    // и сломать логику программы.
    private int hungerLevel = 10; // 0 = сыт, 10 = голоден до потери пульса

    // ============================================
    // КОНСТРУКТОР
    // ============================================
    // Конструктор - это метод, который вызывается при создании объекта.
    // Название = имя класса, без типа возврата.
    public Animal(int initialHunger) {
        if (initialHunger < 0 || initialHunger > 10) {
            throw new IllegalArgumentException("Голод должен быть от 0 до 10, блять!");
        }
        this.hungerLevel = initialHunger;
    }

    // Конструктор по умолчанию (если не указан hunger)
    public Animal() {
        this.hungerLevel = 5; // средний голод
    }

    // ============================================
    // GETTER И SETTER - КОНТРОЛИРУЕМЫЙ ДОСТУП
    // ============================================
    // Это и есть инкапсуляция в действии!
    // Мы не даем прямой доступ к hungerLevel (он private),
    // но даем методы для безопасного доступа.
    
    public int getHungerLevel() {
        return hungerLevel;
    }

    public void setHungerLevel(int hungerLevel) {
        // Валидация! Это важно - не даем установить бредовые значения
        if (hungerLevel < 0) {
            this.hungerLevel = 0;
        } else if (hungerLevel > 10) {
            this.hungerLevel = 10;
        } else {
            this.hungerLevel = hungerLevel;
        }
    }

    // ============================================
    // ПУБЛИЧНЫЕ МЕТОДЫ - ПОВЕДЕНИЕ ОБЪЕКТА
    // ============================================
    
    /**
     * Животное ест. Публичный метод = любой может вызвать.
     * Аналогия: публичный метод = публичная функция (концерт), 
     * private метод = закрытая вечеринка (только внутри класса).
     */
    public void eat() {
        hungerLevel = Math.max(0, hungerLevel - 3); // max - чтобы не уйти в минус
        System.out.println(this.getClass().getSimpleName() + " поел. Уровень голода: " + hungerLevel);
    }

    /**
     * Животное спит. Публичный метод, потому что сон - это нормальное поведение.
     */
    public void sleep() {
        hungerLevel = Math.min(10, hungerLevel + 2); // min - чтобы не превысить 10
        System.out.println(this.getClass().getSimpleName() + " поспал. Уровень голода: " + hungerLevel);
    }

    // ============================================
    // АБСТРАКТНЫЙ МЕТОД - ПРИНЦИП №4
    // ============================================
    // Абстрактный метод = метод БЕЗ реализации.
    // Почему? Потому что каждое животное издает свой звук!
    // Кот говорит "Мяу", собака "Гав", птица "Чирик".
    // 
    // Класс, который наследуется от Animal, ОБЯЗАН реализовать этот метод.
    // Это как договор: "если ты хочешь быть животным, ты ДОЛЖЕН уметь издавать звук!"
    public abstract void makeSound();

    /**
     * Еще один абстрактный метод - игра.
     * Каждое животное играет по-своему:
     * Кот дерется с тенью, собака бегает за мячом, птица летает по клетке.
     */
    public abstract void play();
}



